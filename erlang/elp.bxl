# Copyright (c) Meta Platforms, Inc. and affiliates.
#
# This source code is licensed under both the MIT license found in the
# LICENSE-MIT file in the root directory of this source tree and the Apache
# License, Version 2.0 found in the LICENSE-APACHE file in the root directory
# of this source tree.

# Provide information so that ELP is able to load a BUCK project

load("@prelude//:paths.bzl", "paths")

# ------------------ IMPL ------------------

def _add_includes_to_map(includes_map, includes):
    for include in includes:
        include_path = include["value"]
        include_type = include["type"]
        includes_map[include_path] = include_type
    return includes_map

def _clean_up_includes(includes):
    # - Strip to just dir, not file name
    # - Remove duplicates
    # Note: Sometimes the buck rule generating the includes has an excludes glob for a directory.
    #       This flattening will potentially expose excluded files in the directory.
    #       But we do it, because otherwise the performance in erlang_service parsing is too poor.
    #       For generated include files we cannot perform this optimisation, instead we list them
    #       individually.
    dirs_seen = set([])
    clean_includes = []
    for i in includes:
        if i["type"] == "path":
            d = paths.dirname(i["value"])
            if d not in dirs_seen:
                i["value"] = d
                clean_includes.append(i)
                dirs_seen.add(d)
        elif i["type"] == "build":
            clean_includes.append(i)

    return list(clean_includes)

def _get_includes(ctx, includes_target):
    includes = []
    for inc in includes_target:
        includes.extend(_get_absolute_paths(ctx, inc))
    return _clean_up_includes(includes)

def _get_absolute_path(ctx, src) -> dict[str, str | bxl.EnsuredArtifact]:
    return _get_absolute_path_impl(ctx, src, return_multiple = False)

def _get_absolute_paths(ctx, src) -> list[dict[str, str | bxl.EnsuredArtifact]]:
    return _get_absolute_path_impl(ctx, src, return_multiple = True)

def _get_absolute_path_impl(ctx, src, return_multiple = True) -> dict[str, str | bxl.EnsuredArtifact] | list[dict[str, str | bxl.EnsuredArtifact]]:
    """
    Get the absolute path of the thing passed in, which is either an artifact or a target label.
    """
    is_configured_providers_label = isinstance(src, ConfiguredProvidersLabel)
    if is_configured_providers_label:
        if ctx.cli_args.build_generated_code:
            target = src.configured_target()
            build_results = ctx.build(src)
            build_result = build_results[src]
            failed_targets = []
            for _ in build_result.failures():
                failed_targets.append(str(target))
            if failed_targets != []:
                return _get_return(return_multiple, _as_error("target {} failed to build due to failures on the following targets [{}]".format(target, ", ".join(failed_targets))))
            paths = ctx.output.ensure_multiple(build_result.artifacts())
            if return_multiple:
                return [_as_build(path.abs_path()) for path in paths]
            elif len(paths) == 1:
                return paths[0]
            else:
                return _as_error("target {} has multiple outputs: {}".format(target, ", ".join([str(p) for p in paths])))
        else:
            return _get_return(return_multiple, _as_target(str(src.raw_target())))
    else:
        return _get_return(return_multiple, _as_path(get_path_without_materialization(src, ctx, abs = True)))

def _get_return(make_singleton, x):
    return [x] if make_singleton else x

def _elp_config(ctx):
    # Load the prelude targets first, so if we are working in the prelude they will be overwritten
    # by included or deps targets, and processed in ELP

    included_targets = ctx.configured_targets(ctx.cli_args.included_targets)
    all_targets = ctx.cquery().deps(ctx.configured_targets(included_targets))
    deps_targets = all_targets - included_targets

    all = {tgt.label.raw_target(): ("app", tgt) for tgt in ctx.cquery().kind("^(erlang_app|erlang_test)$", included_targets)}
    all.update({tgt.label.raw_target(): ("dep", tgt) for tgt in ctx.cquery().kind("^erlang_app$", deps_targets)})

    result = {}
    for label_name, (typ, target) in all.items():
        includes_map = {}
        includes = target.get_attr("includes")
        if not includes:
            includes = []
        else:
            includes = _get_includes(ctx, includes)
        includes_map = _add_includes_to_map(includes_map, includes)

        apps_list = []
        included_apps_list = []
        deps = target.get_attr("deps")
        deps_list = [tgt.raw_target() for tgt in deps] if deps else []

        apps = target.get_attr("applications")
        apps_list = [tgt.raw_target() for tgt in apps] if apps else []

        included_apps = target.get_attr("included_applications")
        included_apps_list = [tgt.raw_target() for tgt in included_apps] if included_apps else []

        srcs_attr = target.get_attr("srcs")
        srcs = []
        if srcs_attr:
            for src in srcs_attr:
                srcs.extend(_get_absolute_paths(ctx, src))

        suite = target.get_attr("suite")
        if suite:
            suite_info = _get_absolute_path(ctx, suite)
            if _is_path_or_build(suite_info):
                suite = suite_info["value"]
            else:
                suite = None

        includes = [p for p, t in includes_map.items() if t in ["path", "build"]]
        srcs_out = _construct_output(srcs)
        result[label_name] = dict(
            name = target.get_attr("name"),
            app_name = target.get_attr("app_name"),
            suite = suite,
            srcs = srcs_out,
            includes = includes,
            labels = target.get_attr("labels"),
            deps = deps_list,
            apps = apps_list,
            included_apps = included_apps_list,
            origin = typ,
        )

    ctx.output.print_json(result)

def _construct_output(items: list[dict[str, str | bxl.EnsuredArtifact]]) -> list[str | bxl.EnsuredArtifact]:
    # we completely ignore targets, since we don't have support for generated files in ELP
    paths = _list_dedupe([p["value"] for p in items if _is_path_or_build(p)])
    return paths

def _list_dedupe(xs):
    return list(set(xs))

def _is_path_or_build(item: dict[str, str | bxl.EnsuredArtifact]):
    return item["type"] in ["path", "build"]

def _as_path(src):
    return {"type": "path", "value": src}

def _as_target(src):
    return {"type": "target", "value": src}

def _as_build(artifact):
    return {"type": "build", "value": artifact}

def _as_error(error):
    warning("ERROR: {}".format(error))
    return {"type": "error", "value": error}

# ------------------ INTERFACE ------------------

elp_config = bxl_main(
    impl = _elp_config,
    cli_args = {
        "build_generated_code": cli_args.option(cli_args.bool(), default = False, doc = "Enable builds for generated sources"),
        "deps_targets": cli_args.option(cli_args.list(cli_args.string()), doc = "Target to include deps from, if specified. See corresponding field in .elp.toml"),
        "included_targets": cli_args.list(cli_args.string(), doc = "Targets to include in the query. See corresponding field in .elp.toml"),
    },
)

# Run with `buck2 bxl prelude//erlang/elp.bxl:elp_config`
# e.g.
# buck2 bxl prelude//erlang/elp.bxl:elp_config -- --included_targets cell//...
